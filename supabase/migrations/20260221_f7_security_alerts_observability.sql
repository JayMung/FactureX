-- F7 — OBSERVABILITÉ & ALERTES SÉCURITÉ
-- Système complet d'alertes proactives multi-tenant
-- Phases 1-4: Table, Triggers, Spike Detection, pg_cron

-- ============================================================================
-- PHASE 1: Table security_alerts + indexes
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.security_alerts (
  id              uuid        PRIMARY KEY DEFAULT gen_random_uuid(),
  alert_type      text        NOT NULL,
  severity        text        NOT NULL CHECK (severity IN ('critical', 'high', 'medium', 'low')),
  title           text        NOT NULL,
  description     text,
  source_table    text,
  source_record_id uuid,
  triggered_by    uuid        REFERENCES auth.users(id) ON DELETE SET NULL,
  organization_id uuid        REFERENCES public.organizations(id) ON DELETE CASCADE,
  metadata        jsonb       DEFAULT '{}'::jsonb,
  status          text        NOT NULL DEFAULT 'open' CHECK (status IN ('open', 'acknowledged', 'resolved', 'dismissed')),
  resolved_by     uuid        REFERENCES auth.users(id) ON DELETE SET NULL,
  resolved_at     timestamptz,
  discord_sent    boolean     NOT NULL DEFAULT false,
  discord_sent_at timestamptz,
  created_at      timestamptz NOT NULL DEFAULT now()
);

-- Performance indexes
CREATE INDEX IF NOT EXISTS idx_security_alerts_status_severity
  ON public.security_alerts (status, severity)
  WHERE status IN ('open', 'acknowledged');

CREATE INDEX IF NOT EXISTS idx_security_alerts_org_created
  ON public.security_alerts (organization_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_security_alerts_type
  ON public.security_alerts (alert_type);

CREATE INDEX IF NOT EXISTS idx_security_alerts_discord_pending
  ON public.security_alerts (discord_sent, created_at)
  WHERE discord_sent = false AND status = 'open';

-- RLS
ALTER TABLE public.security_alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.security_alerts FORCE ROW LEVEL SECURITY;

CREATE POLICY "security_alerts_select_admin"
  ON public.security_alerts FOR SELECT
  USING (
    (auth.jwt() -> 'app_metadata' ->> 'role') IN ('admin', 'super_admin')
    AND organization_id IN (
      SELECT p.organization_id FROM public.profiles p WHERE p.id = auth.uid()
    )
  );

CREATE POLICY "security_alerts_update_admin"
  ON public.security_alerts FOR UPDATE
  USING (
    (auth.jwt() -> 'app_metadata' ->> 'role') IN ('admin', 'super_admin')
    AND organization_id IN (
      SELECT p.organization_id FROM public.profiles p WHERE p.id = auth.uid()
    )
  )
  WITH CHECK (
    (auth.jwt() -> 'app_metadata' ->> 'role') IN ('admin', 'super_admin')
    AND organization_id IN (
      SELECT p.organization_id FROM public.profiles p WHERE p.id = auth.uid()
    )
  );

-- System insert (triggers use SECURITY DEFINER, so they bypass RLS as postgres)
CREATE POLICY "security_alerts_insert_system"
  ON public.security_alerts FOR INSERT
  WITH CHECK (true);

GRANT SELECT, UPDATE ON public.security_alerts TO authenticated;
GRANT ALL ON public.security_alerts TO service_role;

COMMENT ON TABLE public.security_alerts IS
  'Proactive security alerts generated by DB triggers and cron jobs. Multi-tenant isolated.';

-- ============================================================================
-- PHASE 2: Helper function to create alerts
-- ============================================================================

CREATE OR REPLACE FUNCTION public.create_security_alert(
  p_alert_type    text,
  p_severity      text,
  p_title         text,
  p_description   text,
  p_source_table  text DEFAULT NULL,
  p_source_record_id uuid DEFAULT NULL,
  p_triggered_by  uuid DEFAULT NULL,
  p_organization_id uuid DEFAULT NULL,
  p_metadata      jsonb DEFAULT '{}'::jsonb
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_alert_id uuid;
BEGIN
  INSERT INTO public.security_alerts (
    alert_type, severity, title, description,
    source_table, source_record_id,
    triggered_by, organization_id, metadata
  ) VALUES (
    p_alert_type, p_severity, p_title, p_description,
    p_source_table, p_source_record_id,
    p_triggered_by, p_organization_id, p_metadata
  )
  RETURNING id INTO v_alert_id;

  RETURN v_alert_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.create_security_alert(text, text, text, text, text, uuid, uuid, uuid, jsonb) TO service_role;

-- ============================================================================
-- PHASE 2A: ROLE_CHANGE alert trigger
-- Fires when set_user_role() modifies admin_roles or when app_metadata.role changes
-- ============================================================================

CREATE OR REPLACE FUNCTION public.alert_on_role_change()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_old_role text;
  v_new_role text;
  v_user_email text;
  v_org_id uuid;
  v_actor_id uuid;
BEGIN
  -- Extract role info
  v_old_role := COALESCE(OLD.role, 'none');
  v_new_role := COALESCE(NEW.role, 'none');

  -- Skip if role didn't actually change
  IF v_old_role = v_new_role THEN
    RETURN NEW;
  END IF;

  -- Get user email
  SELECT email INTO v_user_email
    FROM auth.users WHERE id = NEW.user_id;

  -- Get organization from profile
  SELECT organization_id INTO v_org_id
    FROM public.profiles WHERE id = NEW.user_id;

  -- Actor is current user (the admin performing the change)
  v_actor_id := auth.uid();

  PERFORM public.create_security_alert(
    'ROLE_CHANGE',
    'critical',
    'Changement de rôle utilisateur',
    format('Rôle de %s changé: %s → %s', COALESCE(v_user_email, NEW.user_id::text), v_old_role, v_new_role),
    'admin_roles',
    NEW.id,
    v_actor_id,
    v_org_id,
    jsonb_build_object(
      'target_user_id', NEW.user_id,
      'target_email', v_user_email,
      'old_role', v_old_role,
      'new_role', v_new_role,
      'is_active', NEW.is_active
    )
  );

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trigger_alert_role_change ON public.admin_roles;
CREATE TRIGGER trigger_alert_role_change
  AFTER INSERT OR UPDATE ON public.admin_roles
  FOR EACH ROW
  EXECUTE FUNCTION public.alert_on_role_change();

-- ============================================================================
-- PHASE 2B: RATE_MODIFICATION alert trigger
-- Fires when exchange rates are changed in settings
-- ============================================================================

CREATE OR REPLACE FUNCTION public.alert_on_rate_modification()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_org_id uuid;
  v_actor_id uuid;
  v_old_value text;
  v_new_value text;
BEGIN
  -- Only fire for taux_change settings
  IF NEW.key NOT LIKE 'taux_change/%' THEN
    RETURN NEW;
  END IF;

  v_old_value := COALESCE(OLD.value, 'N/A');
  v_new_value := COALESCE(NEW.value, 'N/A');

  -- Skip if value didn't change
  IF v_old_value = v_new_value THEN
    RETURN NEW;
  END IF;

  v_org_id := COALESCE(NEW.organization_id, OLD.organization_id);
  v_actor_id := auth.uid();

  PERFORM public.create_security_alert(
    'RATE_MODIFICATION',
    'high',
    'Modification taux de change',
    format('Taux %s modifié: %s → %s', NEW.key, v_old_value, v_new_value),
    'settings',
    NEW.id,
    v_actor_id,
    v_org_id,
    jsonb_build_object(
      'setting_key', NEW.key,
      'old_value', v_old_value,
      'new_value', v_new_value
    )
  );

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trigger_alert_rate_modification ON public.settings;
CREATE TRIGGER trigger_alert_rate_modification
  AFTER UPDATE ON public.settings
  FOR EACH ROW
  EXECUTE FUNCTION public.alert_on_rate_modification();

-- ============================================================================
-- PHASE 2C: DELETE sensible alert trigger
-- Fires on DELETE of transactions, factures, comptes_financiers, clients
-- ============================================================================

CREATE OR REPLACE FUNCTION public.alert_on_sensitive_delete()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_org_id uuid;
  v_actor_id uuid;
  v_record_label text;
  v_severity text;
BEGIN
  v_actor_id := auth.uid();
  v_org_id := OLD.organization_id;

  -- Build a human-readable label for the deleted record
  CASE TG_TABLE_NAME
    WHEN 'transactions' THEN
      v_record_label := format('Transaction %s (%s %s)',
        OLD.id::text,
        COALESCE(OLD.montant::text, '?'),
        COALESCE(OLD.devise, 'USD'));
      v_severity := 'high';
    WHEN 'factures' THEN
      v_record_label := format('Facture %s',
        COALESCE(OLD.facture_number, OLD.id::text));
      v_severity := 'high';
    WHEN 'comptes_financiers' THEN
      v_record_label := format('Compte financier %s',
        COALESCE(OLD.nom, OLD.id::text));
      v_severity := 'critical';
    WHEN 'clients' THEN
      v_record_label := format('Client %s',
        COALESCE(OLD.nom, OLD.id::text));
      v_severity := 'high';
    ELSE
      v_record_label := format('%s %s', TG_TABLE_NAME, OLD.id::text);
      v_severity := 'medium';
  END CASE;

  PERFORM public.create_security_alert(
    'SENSITIVE_DELETE',
    v_severity,
    format('Suppression: %s', TG_TABLE_NAME),
    format('%s supprimé(e) par %s', v_record_label, COALESCE(v_actor_id::text, 'système')),
    TG_TABLE_NAME,
    OLD.id,
    v_actor_id,
    v_org_id,
    jsonb_build_object(
      'deleted_record', to_jsonb(OLD),
      'table', TG_TABLE_NAME
    )
  );

  RETURN OLD;
END;
$$;

-- Attach to sensitive tables
DROP TRIGGER IF EXISTS trigger_alert_sensitive_delete_transactions ON public.transactions;
CREATE TRIGGER trigger_alert_sensitive_delete_transactions
  BEFORE DELETE ON public.transactions
  FOR EACH ROW
  EXECUTE FUNCTION public.alert_on_sensitive_delete();

DROP TRIGGER IF EXISTS trigger_alert_sensitive_delete_factures ON public.factures;
CREATE TRIGGER trigger_alert_sensitive_delete_factures
  BEFORE DELETE ON public.factures
  FOR EACH ROW
  EXECUTE FUNCTION public.alert_on_sensitive_delete();

DROP TRIGGER IF EXISTS trigger_alert_sensitive_delete_comptes ON public.comptes_financiers;
CREATE TRIGGER trigger_alert_sensitive_delete_comptes
  BEFORE DELETE ON public.comptes_financiers
  FOR EACH ROW
  EXECUTE FUNCTION public.alert_on_sensitive_delete();

DROP TRIGGER IF EXISTS trigger_alert_sensitive_delete_clients ON public.clients;
CREATE TRIGGER trigger_alert_sensitive_delete_clients
  BEFORE DELETE ON public.clients
  FOR EACH ROW
  EXECUTE FUNCTION public.alert_on_sensitive_delete();

-- ============================================================================
-- PHASE 3: detect_facture_spike() — anomaly detection
-- Detects unusual spikes in facture creation (>3x the 7-day average in 1 hour)
-- ============================================================================

CREATE OR REPLACE FUNCTION public.detect_facture_spike()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  r RECORD;
  v_hourly_count integer;
  v_daily_avg numeric;
  v_hourly_avg numeric;
  v_threshold numeric;
  v_already_alerted boolean;
BEGIN
  -- Check per organization
  FOR r IN
    SELECT DISTINCT organization_id FROM public.factures WHERE organization_id IS NOT NULL
  LOOP
    -- Count factures created in the last hour
    SELECT COUNT(*) INTO v_hourly_count
      FROM public.factures
      WHERE organization_id = r.organization_id
        AND created_at >= now() - interval '1 hour';

    -- Average daily facture count over last 7 days (excluding today)
    SELECT COALESCE(AVG(daily_count), 0) INTO v_daily_avg
      FROM (
        SELECT COUNT(*) as daily_count
          FROM public.factures
          WHERE organization_id = r.organization_id
            AND created_at >= now() - interval '7 days'
            AND created_at < date_trunc('day', now())
          GROUP BY date_trunc('day', created_at)
      ) sub;

    -- Convert daily average to hourly average (assume 10 active hours/day)
    v_hourly_avg := GREATEST(v_daily_avg / 10.0, 1.0);

    -- Threshold: 3x the hourly average, minimum 5
    v_threshold := GREATEST(v_hourly_avg * 3.0, 5.0);

    -- Check if spike detected
    IF v_hourly_count > v_threshold THEN
      -- Avoid duplicate alerts within the last hour
      SELECT EXISTS(
        SELECT 1 FROM public.security_alerts
        WHERE alert_type = 'FACTURE_SPIKE'
          AND organization_id = r.organization_id
          AND created_at >= now() - interval '1 hour'
          AND status = 'open'
      ) INTO v_already_alerted;

      IF NOT v_already_alerted THEN
        PERFORM public.create_security_alert(
          'FACTURE_SPIKE',
          'high',
          'Pic anormal de création de factures',
          format('%s factures créées dans la dernière heure (moyenne: %.1f/h, seuil: %.1f)',
            v_hourly_count, v_hourly_avg, v_threshold),
          'factures',
          NULL,
          NULL,
          r.organization_id,
          jsonb_build_object(
            'hourly_count', v_hourly_count,
            'hourly_average', round(v_hourly_avg::numeric, 2),
            'threshold', round(v_threshold::numeric, 2),
            'daily_average_7d', round(v_daily_avg::numeric, 2)
          )
        );
      END IF;
    END IF;
  END LOOP;
END;
$$;

GRANT EXECUTE ON FUNCTION public.detect_facture_spike() TO service_role;

COMMENT ON FUNCTION public.detect_facture_spike IS
  'Detects anomalous spikes in facture creation per organization. Called by pg_cron every 5 minutes.';

-- ============================================================================
-- PHASE 4: pg_cron jobs (applied manually via execute_sql)
-- ============================================================================

-- pg_cron jobs scheduled:
--
-- 1. detect_facture_spike_job — every 5 minutes
--    SELECT cron.schedule('detect_facture_spike_job', '*/5 * * * *', 'SELECT public.detect_facture_spike()');
--
-- 2. cleanup_old_security_alerts_job — daily at 3 AM
--    SELECT cron.schedule('cleanup_old_security_alerts_job', '0 3 * * *', 'SELECT public.cleanup_old_security_alerts()');
--
-- 3. send_security_alerts_discord_job — every 5 minutes (calls Edge Function via pg_net)
--    SELECT cron.schedule('send_security_alerts_discord_job', '*/5 * * * *', $$
--      SELECT net.http_post(
--        url := 'https://ddnxtuhswmewoxrwswzg.supabase.co/functions/v1/security-alerts-discord',
--        headers := jsonb_build_object('Authorization', 'Bearer <anon_key>', 'Content-Type', 'application/json')
--      ) AS request_id;
--    $$);

-- ============================================================================
-- PHASE 2+: RPC to fetch unresolved alerts for Edge Function
-- ============================================================================

CREATE OR REPLACE FUNCTION public.get_pending_security_alerts(p_limit integer DEFAULT 20)
RETURNS TABLE (
  id uuid,
  alert_type text,
  severity text,
  title text,
  description text,
  source_table text,
  organization_id uuid,
  metadata jsonb,
  status text,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    sa.id,
    sa.alert_type,
    sa.severity,
    sa.title,
    sa.description,
    sa.source_table,
    sa.organization_id,
    sa.metadata,
    sa.status,
    sa.created_at
  FROM public.security_alerts sa
  WHERE sa.discord_sent = false
    AND sa.status = 'open'
  ORDER BY
    CASE sa.severity
      WHEN 'critical' THEN 1
      WHEN 'high' THEN 2
      WHEN 'medium' THEN 3
      WHEN 'low' THEN 4
    END,
    sa.created_at ASC
  LIMIT p_limit;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_pending_security_alerts(integer) TO service_role;

-- RPC to mark alerts as sent to Discord
CREATE OR REPLACE FUNCTION public.mark_alerts_discord_sent(p_alert_ids uuid[])
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_count integer;
BEGIN
  UPDATE public.security_alerts
  SET discord_sent = true,
      discord_sent_at = now()
  WHERE id = ANY(p_alert_ids)
    AND discord_sent = false;

  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;

GRANT EXECUTE ON FUNCTION public.mark_alerts_discord_sent(uuid[]) TO service_role;

-- RPC for admins to resolve/acknowledge alerts
CREATE OR REPLACE FUNCTION public.resolve_security_alert(
  p_alert_id uuid,
  p_status text DEFAULT 'resolved'
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF p_status NOT IN ('resolved', 'acknowledged', 'dismissed') THEN
    RAISE EXCEPTION 'Invalid status: %. Must be resolved, acknowledged, or dismissed', p_status;
  END IF;

  -- Verify caller is admin in the same org
  IF NOT EXISTS (
    SELECT 1 FROM public.security_alerts sa
    JOIN public.profiles p ON p.organization_id = sa.organization_id
    WHERE sa.id = p_alert_id
      AND p.id = auth.uid()
      AND (auth.jwt() -> 'app_metadata' ->> 'role') IN ('admin', 'super_admin')
  ) THEN
    RAISE EXCEPTION 'Access denied or alert not found';
  END IF;

  UPDATE public.security_alerts
  SET status = p_status,
      resolved_by = auth.uid(),
      resolved_at = CASE WHEN p_status = 'resolved' THEN now() ELSE resolved_at END
  WHERE id = p_alert_id;

  RETURN true;
END;
$$;

GRANT EXECUTE ON FUNCTION public.resolve_security_alert(uuid, text) TO authenticated;

-- ============================================================================
-- Cleanup: auto-resolve old alerts after 30 days
-- ============================================================================

CREATE OR REPLACE FUNCTION public.cleanup_old_security_alerts()
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_count integer;
BEGIN
  UPDATE public.security_alerts
  SET status = 'resolved',
      resolved_at = now()
  WHERE status IN ('open', 'acknowledged')
    AND created_at < now() - interval '30 days';

  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;

-- Cleanup cron job scheduled via execute_sql (see PHASE 4 comments above)
